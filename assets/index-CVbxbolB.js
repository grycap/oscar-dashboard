var k=Object.defineProperty;var E=(g,t,s)=>t in g?k(g,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):g[t]=s;var z=(g,t,s)=>E(g,typeof t!="symbol"?t+"":t,s);import{t as I,f as B}from"./index-Du_ot_L7.js";class H{constructor({marshaller:t,serializer:s,deserializer:l,serdeContext:c,defaultContentType:m}){z(this,"marshaller");z(this,"serializer");z(this,"deserializer");z(this,"serdeContext");z(this,"defaultContentType");this.marshaller=t,this.serializer=s,this.deserializer=l,this.serdeContext=c,this.defaultContentType=m}async serializeEventStream({eventStream:t,requestSchema:s,initialRequest:l}){const c=this.marshaller,m=s.getEventStreamMember(),S=s.getMemberSchema(m),d=this.serializer,u=this.defaultContentType,h=Symbol("initialRequestMarker"),f={async*[Symbol.asyncIterator](){if(l){const a={":event-type":{type:"string",value:"initial-request"},":message-type":{type:"string",value:"event"},":content-type":{type:"string",value:u}};d.write(s,l);const y=d.flush();yield{[h]:!0,headers:a,body:y}}for await(const a of t)yield a}};return c.serialize(f,a=>{if(a[h])return{headers:a.headers,body:a.body};const y=Object.keys(a).find(n=>n!=="__type")??"",{additionalHeaders:r,body:e,eventType:i,explicitPayloadContentType:v}=this.writeEventBody(y,S,a);return{headers:{":event-type":{type:"string",value:i},":message-type":{type:"string",value:"event"},":content-type":{type:"string",value:v??u},...r},body:e}})}async deserializeEventStream({response:t,responseSchema:s,initialResponseContainer:l}){var y;const c=this.marshaller,m=s.getEventStreamMember(),d=s.getMemberSchema(m).getMemberSchemas(),u=Symbol("initialResponseMarker"),h=c.deserialize(t.body,async r=>{var v,x;const e=Object.keys(r).find(n=>n!=="__type")??"",i=r[e].body;if(e==="initial-response"){const n=await this.deserializer.read(s,i);return delete n[m],{[u]:!0,...n}}else if(e in d){const n=d[e];if(n.isStructSchema()){const o={};let M=!1;for(const[p,w]of n.structIterator()){const{eventHeader:T,eventPayload:C}=w.getMergedTraits();if(M=M||!!(T||C),C)w.isBlobSchema()?o[p]=i:w.isStringSchema()?o[p]=(((v=this.serdeContext)==null?void 0:v.utf8Encoder)??I)(i):w.isStructSchema()&&(o[p]=await this.deserializer.read(w,i));else if(T){const b=(x=r[e].headers[p])==null?void 0:x.value;b!=null&&(w.isNumericSchema()?b&&typeof b=="object"&&"bytes"in b?o[p]=BigInt(b.toString()):o[p]=Number(b):o[p]=b)}}if(M)return{[e]:o}}return{[e]:await this.deserializer.read(n,i)}}else return{$unknown:r}}),f=h[Symbol.asyncIterator](),a=await f.next();if(a.done)return h;if((y=a.value)!=null&&y[u]){if(!s)throw new Error("@smithy::core/protocols - initial-response event encountered in event stream but no response schema given.");for(const[r,e]of Object.entries(a.value))l[r]=e}return{async*[Symbol.asyncIterator](){var r;for((r=a==null?void 0:a.value)!=null&&r[u]||(yield a.value);;){const{done:e,value:i}=await f.next();if(e)break;yield i}}}}writeEventBody(t,s,l){var y;const c=this.serializer;let m=t,S=null,d;const u=s.getSchema()[4].includes(t),h={};if(u){const r=s.getMemberSchema(t);if(r.isStructSchema()){for(const[e,i]of r.structIterator()){const{eventHeader:v,eventPayload:x}=i.getMergedTraits();if(x)S=e;else if(v){const n=l[t][e];let o="binary";i.isNumericSchema()?(-2)**31<=n&&n<=2**31-1?o="integer":o="long":i.isTimestampSchema()?o="timestamp":i.isStringSchema()?o="string":i.isBooleanSchema()&&(o="boolean"),n!=null&&(h[e]={type:o,value:n},delete l[t][e])}}if(S!==null){const e=r.getMemberSchema(S);e.isBlobSchema()?d="application/octet-stream":e.isStringSchema()&&(d="text/plain"),c.write(e,l[t][S])}else c.write(r,l[t])}else throw new Error("@smithy/core/event-streams - non-struct member not supported in event stream union.")}else{const[r,e]=l[t];m=r,c.write(15,e)}const f=c.flush();return{body:typeof f=="string"?(((y=this.serdeContext)==null?void 0:y.utf8Decoder)??B)(f):f,eventType:m,explicitPayloadContentType:d,additionalHeaders:h}}}export{H as EventStreamSerde};
